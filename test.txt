// test.txt

// ─── Basic arithmetic and functions ───────────────────────────────────────────

// Define a simple function
def add(a, b) {
  return a + b
}

let sum2 = add(5, 7)
print("sum2:", sum2)  // Expect: sum2: 12

// Lambda shorthand (Forge) example: increment
let inc = Forge(x): x + 1
print("inc(10):", inc(10))  // Expect: inc(10): 11

// ─── Lists and higher-order functions ────────────────────────────────────────

// Create a list of numbers 0..4
let numbers = range(5)      
print("numbers:", numbers)  // Expect: numbers: [0, 1, 2, 3, 4]

// Filter even numbers using lambda
let evens = filter(Forge(x): x % 2 == 0, numbers)
print("evens:", evens)      // Expect: evens: [0, 2, 4]

// Map: square each number
let squares = map(Forge(x): x * x, numbers)
print("squares:", squares)  // Expect: squares: [0, 1, 4, 9, 16]

// Sum of squares
let totalSquares = sum(squares)
print("totalSquares:", totalSquares) // Expect: totalSquares: 30

// Conditional and loop example
if (totalSquares > 20) {
  print("Total of squares is large:", totalSquares)
} else {
  print("Total of squares is small:", totalSquares)
}

// ─── Literal map usage ───────────────────────────────────────────────────────

// Create a map via literal syntax
let mLiteral = {
  "one": 1,
  two: 2,
  "nested": { a: 10, b: 20 },
  flag: true
}
print("mLiteral:", mLiteral) // Expect something like: mLiteral: {one: 1, two: 2, nested: {a: 10, b: 20}, flag: true}

// Access values
print("mLiteral.one:", get(mLiteral, "one"))            // 1
print("mLiteral.two:", get(mLiteral, "two"))            // 2
print("nested a:", get(get(mLiteral, "nested"), "a"))   // 10
print("flag:", get(mLiteral, "flag"))                   // true
print("len(mLiteral):", len(mLiteral))                  // 4

// Check hasKey
print("hasKey one?", hasKey(mLiteral, "one"))           // true
print("hasKey missing?", hasKey(mLiteral, "missing"))   // false

// Iterate entries of literal map
let literalEntries = entries(mLiteral)  // returns list of [key, value] pairs
for pair in literalEntries {
  let k = pair[0]
  let v = pair[1]
  print("Entry in mLiteral:", k, "=", v)
}

// ─── Constructed HashMap usage ───────────────────────────────────────────────

// Create an empty map via constructor
let m2 = HashMap()
print("Empty m2:", m2)               // Expect: {}

// Put values
put(m2, "foo", 100)
put(m2, "bar", 200)
put(m2, "baz", 300)
print("m2 after puts:", m2)         // Expect: {foo: 100, bar: 200, baz: 300}

// Access
print("m2.foo:", get(m2, "foo"))    // 100
print("m2.bar:", get(m2, "bar"))    // 200
print("m2.unknown:", get(m2, "unknown")) // null

// Keys and values
print("m2 keys:", keys(m2))         // ["foo", "bar", "baz"]
print("m2 values:", values(m2))     // [100, 200, 300]

// entries
for e in entries(m2) {
  // e is [key, value]
  print("m2 entry:", e[0], "->", e[1])
}

// Remove a key
remove(m2, "bar")
print("m2 after remove bar:", m2)   // {foo: 100, baz: 300}
print("hasKey bar?", hasKey(m2, "bar")) // false

// ─── Merging maps ────────────────────────────────────────────────────────────

// Merge literal map and constructed map: keys from mLiteral and m2
// Note: if keys overlap, second map's value overrides first's
let merged = mergeMaps(mLiteral, m2)
print("merged:", merged)
// Check some entries
print("merged.one:", get(merged, "one"))   // from mLiteral => 1
print("merged.foo:", get(merged, "foo"))   // from m2 => 100

// Remove from merged
remove(merged, "one")
print("merged after remove one:", merged)
print("hasKey one?", hasKey(merged, "one"))

// ─── Nested and complex scenarios ────────────────────────────────────────────

// Nested literal maps and loops
let users = {
  "alice": { age: 30, scores: [10, 20, 30] },
  bob: { age: 25, scores: [5, 15, 25] },
  charlie: { age: 35, scores: [20, 30, 40] }
}
print("users:", users)

// Compute average score per user and store in a new HashMap
let avgScores = HashMap()
for entry in entries(users) {
  let username = entry[0]
  let profile = entry[1]
  // profile is a map with keys "age" and "scores"
  let scoresList = get(profile, "scores")
  let total = sum(scoresList)
  let count = len(scoresList)
  // average = total / count
  let avg = total / count
  put(avgScores, username, avg)
}
print("avgScores:", avgScores)

// Use higher-order function map on a list of usernames
let namesList = keys(users)  // ["alice", "bob", "charlie"]
let greetings = map(
  Forge(name): "Hello, " + name + "! Your avg score is " + get(avgScores, name),
  namesList
)
for g in greetings {
  print(g)
}

// Conditional inside loop
for name in namesList {
  let age = get(get(users, name), "age")
  if (age >= 30) {
    print(name + " is 30 or older.")
  } else {
    print(name + " is younger than 30.")
  }
}

// ─── Testing len on various types ─────────────────────────────────────────────

print("len of empty list:", len([]))           // 0
print("len of list [1,2,3]:", len([1,2,3]))     // 3
print("len of empty map:", len({}))             // 0
print("len of users map:", len(users))          // 3

// ─── Error / edge-case checks (optional) ─────────────────────────────────────
// Uncomment to test error handling:
// let bad = HashMap()
// // get with non-string/number/boolean key: e.g., list as key should error
// // print(get(bad, [1,2]))  // Should throw a runtime error about invalid map key

// ─── Final result ─────────────────────────────────────────────────────────────

// Return a final value (optional). For example, return size of merged:
len(merged)
