// Comprehensive Klang test-case
// Save as test.klang and run via: deno run --allow-read main.ts test.klang

// 1. Basic variable declarations
final int a = 10;
let b = 20;
let sumAB = a + b * 2 - (5 + 3);
let flag = true && false || !false;
print("sumAB:", sumAB);               // expect: sumAB: 10 + 40 - 8 = 42?
print("flag:", flag);                 // expect: true && false = false; false || !false = false || true = true

// 2. String concatenation
let greeting = "Hello";
let target = "World";
let message = greeting + ", " + target + "!";
print(message);                       // expect: Hello, World!

// 3. Boolean literal via identifier
let t = true;
let f = false;
print("t AND f:", t && f);            // false
print("t OR f:", t || f);             // true
print("!t:", !t);                     // false

// 4. Null
let nothing = null;
print("nothing:", nothing);           // expect: null

// 5. Function declaration and call
def add(x, y) {
  return x + y;
}
print("add(3,4):", add(3, 4));        // 7

// 6. Recursive function: factorial
def factorial(n) {
  if n == 0 {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
print("factorial(5):", factorial(5)); // 120

// 7. Lists: literal, len, sum, range
let lst = [1, 2, 3, 4, 5];
print("lst:", lst);
print("len(lst):", len(lst));         // 5
print("sum(lst):", sum(lst));         // 1+2+3+4+5 = 15

// Depending on your range builtin: e.g., range(start, end) producing [start,...,end-1] or inclusive
// Here assume range(start, end) yields [start, start+1, ..., end-1]
let r = range(1, 6);
print("range(1,6):", r);              // [1,2,3,4,5]

// 8. Filtering and mapping
def isEven(x) {
  return x % 2 == 0;
}
let evens = filter(lst, isEven);
print("evens:", evens);               // [2,4]

let squares = map(lst, Forge(x): x * x);
print("squares:", squares);           // [1,4,9,16,25]
print("sum(squares):", sum(squares)); // 55

// 9. List indexing (if supported)
let first = lst[0];
let third = lst[2];
print("first, third:", first, third); // 1, 3

// 10. For-in loop over list
for item in lst {
  print("for item:", item);
}

// 11. While loop
let idx = 0;
while idx < len(lst) {
  print("while idx:", idx);
  idx = idx + 1;
}

// 12. Map literal syntax and indexing
let mapLit = { a: 1, b: 2, c: 3 };
print("mapLit:", mapLit);
print("mapLit['b']:", mapLit["b"]);   // 2
print("mapLit.a:", mapLit.a);         // if dot-access supported; if not, skip or comment out

// 13. Builtin HashMap usage
let hm = HashMap();                   // assume builtin constructor
hm.put("one", 1);
hm.put("two", 2);
hm.put("three", 3);
print("hm.get('two'):", hm.get("two")); // 2
print("hm.contains('two'):", hm.contains("two")); // true
print("hm.size():", hm.size());       // 3
hm.remove("two");
print("hm.contains('two') after remove:", hm.contains("two")); // false
print("hm.get('two') after remove:", hm.get("two"));           // null or error depending on implementation

// 14. Higher-order functions
def applyTwice(f, x) {
  return f(f(x));
}
let inc = Forge(x): x + 1;
print("applyTwice(inc, 5):", applyTwice(inc, 5)); // 7

// 15. Assigning function expressions to variables
let mul2 = Def(x) {
  return x * 2;
};
print("mul2(7):", mul2(7));            // 14

// 16. Nested scopes and closures
def outer() {
  let outerVal = 100;
  def inner() {
    return outerVal + 1;
  }
  return inner();
}
print("outer():", outer());            // 101

// 17. Conditional without else
def checkPositive(n) {
  if n > 0 {
    print(n, "is positive");
  }
  // no explicit return here; returns null implicitly
}
checkPositive(5);
let ret = checkPositive(-3);
print("checkPositive(-3) returns:", ret); // null

// 18. Complex expression chaining
let complex = ((a + b) * (factorial(3))) / 2 - (len(lst) || 0);
print("complex:", complex);

// 19. Boolean and/or short-circuit
// Assuming Klang uses lazy evaluation: in `false && expr`, expr not evaluated; in `true || expr`, expr not evaluated
def sideEffect() {
  print("sideEffect called");
  return true;
}
print("false && sideEffect():", false && sideEffect()); // should not print "sideEffect called"
print("true || sideEffect():", true || sideEffect());   // should not print "sideEffect called"

// 20. Mixing map literal with built-in HashMap
let mapFromLit = HashMap();
for entry in ["a","b","c"] {
  mapFromLit.put(entry, mapLit[entry]);
}
print("mapFromLit.get('c'):", mapFromLit.get("c")); // 3

// 21. Optional: demonstrate mutate list
let mutableList = [10, 20, 30];
mutableList[1] = 25;                   // if assignment to index supported
print("mutableList after assignment:", mutableList);

// 22. Edge: empty list and empty map
let emptyList = [];
print("emptyList:", emptyList, "len:", len(emptyList), "sum:", sum(emptyList));
let emptyMap = HashMap();
print("emptyMap.size():", emptyMap.size(), "contains 'x':", emptyMap.contains("x"));

// 23. Lambda shorthand in complex context
let dblAndAdd = Forge(x, y): x * 2 + y;
print("dblAndAdd(3,4):", dblAndAdd(3, 4)); // 10

// 24. Combining filter/map inline
let filteredMapped = map(filter(range(1, 11), Forge(x): x % 2 == 1), Forge(x): x * x);
print("filteredMapped (odd squares 1..10):", filteredMapped);

// End of comprehensive test
